/*
924. Minimize Malware Spread

Hard

https://leetcode.com/problems/minimize-malware-spread/
*/

/*
  找出 initial[i]，能救活最多个node
  也就是 initial[i] 所处的连通分量的node数
  因为题目要求只能删掉一个 initial[i]， 那么不允许有别的 initial[j] 也感染这个连通分量
*/
/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function (graph, initial) {
  const n = graph.length;
  const uf = new UnionFind(n);

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (graph[i][j]) {
        uf.union(i, j);
      }
    }
  }
  const affected = new Array(n).fill(0);
  for (const i of initial) {
    const root = uf.find(i);
    affected[root]++;
  }

  let ans = -1;
  let count = 0; // 最终被感染的节点数
  initial.sort((a, b) => a - b);
  for (const i of initial) {
    const root = uf.find(i);
    //不允许有别的 initial[j] 也感染这个连通分量
    if (affected[root] == 1) {
      if (count < uf.size[root]) {
        count = uf.size[root];
        ans = i;
      }
    }
  }

  if (ans == -1) {
    //
    return initial[0];
  }
  return ans;
};

class UnionFind {
  constructor(n) {
    this.n = n;
    this.size = new Array(n);
    this.root = new Array(n);
    for (let i = 0; i < n; i++) {
      this.size[i] = 1;
      this.root[i] = i;
    }
  }

  find(x) {
    if (this.root[x] != x) {
      this.root[x] = this.find(this.root[x]);
    }
    return root[x];
  }

  union(a, b) {
    const root_a = this.find(a);
    const root_b = this.find(b);

    if (root_a != root_b) {
      if (this.size[root_a] < this.size[root_b]) {
        this.root[root_a] = root_b;
        this.size[root_a] += this.size[root_b];
      } else {
        this.root[root_b] = root_a;
        this.size[root_b] += this.size[root_a];
      }
    }
  }
}
